//ex-1
// ****[Задержка на промисах](https://learn.javascript.ru/promise-basics#zaderzhka-na-promisah)****

// Встроенная функция `setTimeout` использует колбэк-функции. Создайте альтернативу, использующую промисы.

// Функция `delay(ms)` должна возвращать промис, который перейдёт в состояние «выполнен» через `ms` миллисекунд, так чтобы мы могли добавить к нему `.then`:
function delay(ms) {
  // ваш код
  return new Promise((resolve) => setTimeout(resolve, ms));
}

delay(3000).then(() => alert("выполнилось через 3 секунды"));

// ex-2
// ****[Можно ли "перевыполнить" промис?](https://learn.javascript.ru/promise-basics#mozhno-li-perevypolnit-promis)****
// Что выведет код ниже?
let promise = new Promise(function (resolve, reject) {
  resolve(1);

  setTimeout(() => resolve(2), 1000);
});

promise.then(alert);
//NADO RAZOBRAT"SYA, vyvel code=1. otvet iz knigi:
// Вывод будет: 1.
// Второй вызов resolve будет проигнорирован, поскольку учитывается только первый вызов reject/resolve. Все последующие вызовы – игнорируются.

// ex-3
// ****[Промисы: сравните then и catch](https://learn.javascript.ru/promise-chaining#promisy-sravnite-then-i-catch)****
// Являются ли фрагменты кода ниже эквивалентными? Другими словами, ведут ли они себя одинаково во всех обстоятельствах, для всех переданных им обработчиков?

promise.then(f1).catch(f2);

// Против:
promise.then(f1, f2);
//Answer: это 2 разные фрагменты кода, так как в первом случае если в промис будет ошибка, то отработает f1, а если выйдет ошибка, то отработает f2.
// во втором случае только f1 отработает, в случае же ошибки дальше ничего не будет
// ниже ответ из решения:
// Короткий ответ: нет, они не эквивалентны:
// Разница в том, что если ошибка произойдёт в f1, то она будет обработана в .catch в этом примере:

// promise
//   .then(f1)
//   .catch(f2);
// …но не в этом:

// promise
//   .then(f1, f2);
// Ошибка передаётся по цепочке, но во втором примере нет продолжения цепочки после f1.
// Другими словами, .then передаёт результат или ошибку следующему блоку .then/catch. Так как в первом примере в цепочке далее имеется блок catch, а во втором – нет, то ошибка в нём останется необработанной.
